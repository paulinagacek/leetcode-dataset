class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
	    # save positions of keys in ring for faster search
        poses = {i:[] for i in key}        
        for i in range(len(ring)):
            if ring[i] in poses.keys():
                poses[ring[i]] = poses[ring[i]] + [i]
                    
		# possible ways for the first key
		# for each way: {current_position: amount_of_moves_done} 
        psbl_ways = {}
        for pos in poses[key[0]]:
            mv = min([pos, abs (n - pos)])
            psbl_ways[pos] = mv
                        
        for i in range(1, len(key)):
            dd = {}
            for old_pos, old_mv in psbl_ways.items():
                for pos in poses[key[i]]:
					# find fastest way clock or anti wise
                    mv = min([abs(pos - old_pos), n - abs(pos - old_pos)])
                    mv = old_mv + mv
                    if pos in dd.keys():
						# if there are several ways to current_position we only save the best one
                        dd[pos] = min([dd[pos], mv])
                    else:
                        dd[pos] = mv                    
                    
            psbl_ways = dd
            
        rt = min([v for k,v in psbl_ways.items()])
		# adding amount of button pushes
        return rt + len(key)