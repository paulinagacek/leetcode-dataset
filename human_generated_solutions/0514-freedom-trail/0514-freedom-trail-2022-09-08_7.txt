# pre calculate distance in matrix, > 800ms
class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        m = len(ring)
        char_idxes = defaultdict(list)
        for i in range(m):
            char_idxes[ring[i]].append(i)
        # print(char_idxes)
        # distance calculate 1
        # distances = [[min(i,m-i) for i in range(m)]]
        # for j in range(1,m):
        #     distances.append([distances[-1][-1]] + distances[-1][:-1])
        # distance calculate 2, about the same speed
        distances = [[min(i-j,m-i+j) if i >= j else min(j-i,m-j+i) for j in range(m)] for i in range(m)]
        # print(distances)
        pre = distances[0]
        cur = [math.inf for i in range(m)]
        for char in key:
            for target_pos in char_idxes[char]:
                min_step = math.inf
                for i in range(m):
                    if pre[i] != math.inf:
                        if pre[i] + distances[i][target_pos] < min_step:
                            min_step = pre[i] + distances[i][target_pos]
                cur[target_pos] = min_step
            pre = cur
            cur = [math.inf for i in range(m)]
            # print(pre)
        # every time we need to press, but do nothing with our path, so just add
        return min(pre) + len(key) 


# calculate distance inside, about 300ms
class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        m = len(ring)
        char_idxes = defaultdict(list)
        for i in range(m):
            char_idxes[ring[i]].append(i)
        # print(char_idxes)
        def calculate_distance(i,j):
            return min(i-j,m-i+j) if i >= j else min(j-i,m-j+i)
        pre = [min(i,m-i) for i in range(m)]
        cur = [math.inf for i in range(m)]
        for char in key:
            for target_pos in char_idxes[char]:
                min_step = math.inf
                for i in range(m):
                    if pre[i] != math.inf:
                        temp = pre[i] + calculate_distance(i,target_pos)
                        if temp < min_step:
                            min_step = temp
                cur[target_pos] = min_step
            pre = cur
            cur = [math.inf for i in range(m)]
            # print(pre)
        # every time we need to press, but do nothing with our path, so just add
        return min(pre) + len(key)