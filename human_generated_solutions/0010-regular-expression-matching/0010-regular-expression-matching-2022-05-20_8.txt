class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        memo = {}
        s_index, p_index = 0, 0
        return self.memo_dfs(s, s_index, p, p_index, memo)
    
    def memo_dfs(self, s, i, p, j, memo):
        
        if j == len(p):
            return i == len(s)
        
        if i == len(s):
            return self.could_be_empty(p[j:])
        
        if (i, j) in memo:
            return memo[(i, j)]
        
        if j + 1 < len(p) and  p[j + 1] == \'*\': # matched & not matched
            matched = ((s[i] == p[j] or p[j] == \'.\') and self.memo_dfs(s, i + 1, p, j, memo)) or self.memo_dfs(s, i, p, j + 2, memo)
        else:
            matched = (s[i] == p[j] or p[j] == \'.\') and self.memo_dfs(s, i + 1, p, j + 1, memo)
        
        memo[(i, j)] = matched
        
        return matched
    
    def could_be_empty(self, l):
        if len(l) % 2 == 1:
            return False
        i = 0
        while i < len(l) // 2:
            if l[2 * i + 1] != \'*\':
                return False
            i += 1
        return True