class Hasher:
    MAX = 50002
    MOD = 1000000007
    BASE = 1331
    
    def __init__(self, n):
        Hasher.MAX = n + 2
        self.storage = [0 for _ in range(Hasher.MAX)]
        self.precompute()
    
    def precompute(self):
        self.storage[0] = 1
        for i in range(1, Hasher.MAX):
            self.storage[i] = (self.storage[i-1] * Hasher.BASE) % Hasher.MOD
    
    def populateHash(self, H, s):
        H[0] = 0
        for i, ch in enumerate(s):
            H[i+1] = (H[i] * Hasher.BASE + ord(ch)) % Hasher.MOD
    
    def getHash(self, s):
        hashValue = 0
        for i, ch in enumerate(s):
            hashValue = (hashValue * Hasher.BASE + ord(ch)) % Hasher.MOD
        return hashValue
    
    def getHash(self, H, l, r):
        MOD = Hasher.MOD
        return (H[r] - (H[l-1] * self.storage[r-l+1]) % MOD + MOD) % MOD
        

class Solution:
    def shortestPalindrome(self, s: str) -> str:
        n = len(s)

        hasher = Hasher(n)
        H1 = [0 for _ in range(hasher.MAX)]
        H2 = [0 for _ in range(hasher.MAX)]
        
        hasher.populateHash(H1, s)
        hasher.populateHash(H2, s[::-1])
        
        idx = 0
        for i in range(n):
            if H1[i+1] == hasher.getHash(H2, n - i, n):
                idx = i

        return s[idx+1:][::-1] + s