class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        ## RC ##
		## APPROACH : BACKTRACKING ##
		## LOGIC ##
		#	1. Draw backtracking tree starting with "" and 1st level being number for num 123: its 1 or 12 or 123 (attach *, -, + and send for dfs)
		#	2. When you are the last digit, donot send for dfs, compute the result
        #   3. Check out for some interesting edge cases, interviewer is looking for those you to solve.
		# edge cases : 105 5, 100009 9, 569 45
        
        ## TIME COMPLEXICITY : O(4^N) ## (each level you are creating 4 branches)
		## SPACE COMPLEXICITY : O(4^N) ##
        
        def dfs( curr, num ):
            if curr in visited:
                return
            visited.add(curr)
            for i, ch in enumerate(num):
                if i == len(num) - 1:     # when you are at last digit, calculate the result
                    if eval(curr + num) == target:
                        result.append(curr + num)
                else:
                    dfs( curr + num[:i+1] + "*", num[i+1:])
                    dfs( curr + num[:i+1] + "-", num[i+1:])
                    dfs( curr + num[:i+1] + "+", num[i+1:])
                
                if num[:i+1] == "0":     # edge case, in the number you are sending in if the first digit is 0, donot send further. ex: 105, send 0 but not 05.
                    break
        result = []
        visited = set()
        dfs( "", num )
        return result