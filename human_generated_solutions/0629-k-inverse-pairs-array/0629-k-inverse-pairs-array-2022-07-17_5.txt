MOD = 10 ** 9 + 7


class Solution:

    def kInversePairs(self, N: int, K: int) -> int:
        """
        @see https://leetcode.com/problems/k-inverse-pairs-array/discuss/104815/Java-DP-O(nk)-solution

        let dp[n, k] = number of different arrays containing numbers 1, 2, ..., n with exactly k inverse pairs,
        let max_pairs = n (n - 1) / 2

        dp[n, k] = {
                        0                                                   if n = 0 or k < 0 or k > max_pairs
                        1                                                   if k = 0 or k =  max_pairs
            dp[n - 1, k] + dp[n - 1, k - 1] + ... + d[n - 1, k - (n - 1)]   otherwise
        }

        Simplifying the 3rd relation,

        dp[n, k] = sum(dp[n - 1, k - i] for i in range(n))
                 = dp[n - 1, k] + sum(dp[n - 1, k - i] for i in range(1, n))

        dp[n, k - 1] = sum(dp[n - 1, k - 1 - i] for i in range(n))
             = sum(dp[n - 1, k - (i + 1)] for i in range(n))
             = sum(dp[n - 1, k - j] for j in range(1, n + 1)) # let j = i + 1, since 0 <= i < n so 1 <= j < n + 1
             = sum(dp[n - 1, k - j] for j in range(1, n)) + dp[n - 1, k - n] # separating last term in the summation
             = sum(dp[n - 1, k - i] for i in range(1, n)) + dp[n - 1, k - n] # changing the index variable

        so,

        dp[n, k]      = dp[n - 1, k] + sum(dp[n - 1, k - i] for i in range(1, n))
        dp[n, k - 1]  =              + sum(dp[n - 1, k - i] for i in range(1, n)) + dp[n - 1, k - n]
        ------------------------------------------------------------- (subtracting them)
        dp[n, k] - dp[n, k - 1] = dp[n - 1, k] - dp[n - 1, k - n]

        that is,
        dp[n, k] =  dp[n - 1, k] + (dp[n, k - 1] - dp[n - 1, k - n])

        :param N:
        :param K:
        :return: dp[N, K]
        """
        max_pairs = (N * (N - 1)) // 2

        if N == 0 or K < 0 or K > max_pairs:
            return 0
        elif K == 0 or K == max_pairs:
            return 1
        # return self.memo(N, K)
        # return self.dynamic_programming(N, K)
        return self.dynamic_programming_space_optimized(N, K)

    @staticmethod
    def memo(N: int, K: int) -> int:
        from functools import cache

        @cache
        def dp(n: int, k: int) -> int:
            max_pairs = (n * (n - 1)) // 2

            if n == 0 or k < 0 or k > max_pairs:  # no inverse pair possible
                return 0
            elif k == 0 or k == max_pairs:  # exactly one inverse pair possible
                return 1
            else:
                return (dp(n - 1, k) + dp(n, k - 1) - dp(n - 1, k - n)) % MOD

        return dp(N, K)

    @staticmethod
    def dynamic_programming(N: int, K: int) -> int:
        dp = [[0] * (K + 1) for _ in range(N + 1)]

        for n in range(1, N + 1):
            dp[n][0] = 1

            max_pairs = (n * (n - 1)) // 2
            max_k = min(K, max_pairs)  # there is no point populating dp[n][k] when k > max_k as it will be zero

            for k in range(1, max_k + 1):
                dp[n][k] = dp[n][k - 1] + dp[n - 1][k]

                if k >= n:
                    dp[n][k] -= dp[n - 1][k - n]

                dp[n][k] %= MOD

        return dp[N][K]

    @staticmethod
    def dynamic_programming_space_optimized(N: int, K: int) -> int:
        dp = [0] * (K + 1)

        for n in range(1, N + 1):
            tmp = [0] * (K + 1)
            tmp[0] = 1

            max_pairs = (n * (n - 1)) // 2
            max_k = min(K, max_pairs)  # there is no point populating dp[n][k] when k > max_k as it will be zero

            for k in range(1, max_k + 1):
                tmp[k] = tmp[k - 1] + dp[k]

                if k >= n:
                    tmp[k] -= dp[k - n]

                tmp[k] %= MOD

            dp = tmp

        return dp[K]

    @staticmethod
    def dynamic_programming_sliding_window(N: int, K: int) -> int:
        dp = [[0] * (K + 1) for _ in range(N + 1)]

        for n in range(1, N + 1):
            dp[n][0] = cum_sum = 1  # cum_sum will have sum of n numbers

            max_pairs = (n * (n - 1)) // 2
            max_k = min(K, max_pairs)

            for k in range(1, max_k + 1):  # there is no point populating dp[n][k] when k > max_k as it will be zero
                cum_sum += dp[n - 1][k]

                if k >= n:
                    cum_sum -= dp[n - 1][k - n]  # making sure number, outside of window of size n, is removed

                dp[n][k] = cum_sum % MOD

        return dp[N][K]