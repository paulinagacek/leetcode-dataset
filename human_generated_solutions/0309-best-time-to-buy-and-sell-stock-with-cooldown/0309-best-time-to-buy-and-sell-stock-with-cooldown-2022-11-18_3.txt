def maxProfit(self, prices: List[int]) -> int:    
        res = 0
        
        def dfs(i, state, profit):
            nonlocal res
            if i >= len(prices):
				# Keep track of the maximum profit
                res = max(profit, res)
                return
            
			# STATE: We don\'t have a stock and need to buy one
            if state == \'b\':
				# DECISION #1 
				# Set state to \'s\' because we bought a stock and are looking to sell
				# Our profit decreases because we spent money to buy the stock
                dfs(i + 1, \'s\', profit - prices[i])
				# DECISION #2
				# This spot might be too expensive
				# Let\'s buy a stock the next day instead
                dfs(i + 1, \'b\', profit)
            else: # STATE: We already bought a stock and are looking to sell
				# DECISION #3
				# Set state to \'b\'. We sold our stock and we are looking to buy again
				# Our profit increases 
				# Remember Requirement #1!!! 
				# We have to skip the next day so we set i + 2 instead of i + 1
                dfs(i + 2, \'b\', profit + prices[i])
				# DECISION #4
				# The stock might be too cheap today, let\'s wait to sell the next day
				# Note we remain on the sell state
                dfs(i + 1, \'s\', profit)
		# Initially we HAVE TO BUY, we don\'t have a stock yet
        dfs(0, \'b\', 0)
        return res