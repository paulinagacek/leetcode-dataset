def maxSumOfThreeSubarrays(self, A: List[int], k: int, m=3) -> List[int]:
        n = len(A)
        dp = [[0]*(m+1) for _ in range(n+1)]
        index = [[0]*(m+1) for _ in range(n+1)]
        
        presum = [0]
        sum_ = 0 # IMP for 1-based operations
        for a in A:
            sum_ += a
            presum.append(sum_)

        for sn in range(1,m+1): # 1-based serial number of subarray 1,2,3
            for i in range(k*sn, len(A)+1): # iterate the presum from k:end, 2k:end and 3k:end
                max_prev_sum = dp[i-k][sn-1] + presum[i] - presum[i-k]
                
                if dp[i-1][sn] < max_prev_sum: #very IMP: check whether "PREV" index\'s state is smaller otherwise new window with same sum will be considered (lexic\'l bigger).
                    dp[i][sn] = max_prev_sum
                    index[i][sn] = i-k # store index of current subarray start
                else:
                    dp[i][sn] = dp[i-1][sn] # copy previous max subarray
                    index[i][sn] = index[i-1][sn] # copy index of prev max subarray
                    
        res = []
        i, sn = n, m # start from 3rd subarray and move towards 1st
        for _ in range(m):
            res.append(index[i][sn])
            i = index[i][sn]
            sn -= 1
        return res[::-1]