class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        subtreeXor = [0]*n
        g = [[] for i in range(n)]
        for i,j in edges:
            g[i].append(j)
            g[j].append(i)
        def xorDFS(n,p):
            xor = nums[n]
            for c in g[n]:
                if c!=p:
                    xorDFS(c,n)
                    xor^=subtreeXor[c]
            subtreeXor[n] = xor
        xorDFS(0,-1)
        st = [0]
        vis = [0]*n
        vis[0] = 1
        ans = 100000000000000
        def dfs1(node,p,anc):
            anc[node]=1
            for c in g[node]:
                if c!=p:
                    def dfs(nn,pp,aa):
                        nonlocal ans
                        aa[nn]=1
                        for cc in g[nn]:
                            if cc!=pp:
                                dfs(cc,nn,aa)
                                if node==nn and c==cc:
                                    continue
                                if anc[cc]:
                                    continue
                                if (aa[c]):
                                    xor1 = subtreeXor[c]^subtreeXor[cc]
                                    xor2 = subtreeXor[cc]
                                    xor3 = subtreeXor[0]^xor1^xor2
                                    ans = min(ans , max(xor1,xor2,xor3) - min(xor1,xor2,xor3))
                                    continue
                                if n!=cc and c!=nn:
                                    xor1 = subtreeXor[c]
                                    xor2 = subtreeXor[cc]
                                    xor3 = subtreeXor[0]^xor1^xor2
                                    ans = min(ans , max(xor1,xor2,xor3) - min(xor1,xor2,xor3))
                                elif c==nn:
                                    xor1 = subtreeXor[c]^subtreeXor[cc]
                                    xor2 = subtreeXor[cc]
                                    xor3 = subtreeXor[0]^xor1^xor2
                                    ans = min(ans , max(xor1,xor2,xor3) - min(xor1,xor2,xor3))
                                else:
                                    c1 = c
                                    c1,cc=cc,c1
                                    xor1 = subtreeXor[c1]^subtreeXor[cc]
                                    xor2 = subtreeXor[cc]
                                    xor3 = subtreeXor[0]^xor1^xor2
                                    ans = min(ans , max(xor1,xor2,xor3) - min(xor1,xor2,xor3))
                        aa[nn]=0
                    dfs(0,-1,[0]*len(nums))
                    dfs1(c,node,anc)
            anc[node] = 0  
        dfs1(0,-1,[0]*n)      
        return ans