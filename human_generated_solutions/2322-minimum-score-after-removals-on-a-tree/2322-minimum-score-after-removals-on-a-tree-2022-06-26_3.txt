def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
	n = len(nums)
	g = [set() for _ in range(n)]
	for u, v in edges:
		g[u].add(v)
		g[v].add(u)
	oss = [set() for _ in range(n)] # offsprings of each node with node 0 as the root. 
	xs = nums.copy()  # xor of each subtree with node 0 as the root. 
	def dfs(node, prev):
		if prev is not None: g[node].remove(prev)
		for q in g[node]:
			oss[node].add(q)
			dfs(q, node)
			oss[node].update(oss[q])
			xs[node] ^= xs[q]
	dfs(0, None)

	mn = float(\'inf\')
	for i, (u1, v1) in enumerate(edges[:-1]):
		for u2, v2 in edges[i+1:]:
			p1, p2 = u1 if u1 in g[v1] else v1, u2 if u2 in g[v2] else v2
			if p1 in oss[p2]: p1, p2 = p2, p1
			if p2 in oss[p1]:
				x0, x1, x2 = xs[0] ^ xs[p1], xs[p1] ^ xs[p2], xs[p2]
			else:
				x0, x1, x2 = xs[0] ^ xs[p1] ^ xs[p2], xs[p1], xs[p2]
			mn = min(mn, max(x0, x1, x2) - min(x0, x1, x2))
	return mn