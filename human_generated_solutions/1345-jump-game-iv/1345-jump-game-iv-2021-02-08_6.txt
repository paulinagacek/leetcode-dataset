\'\'\'
w: minimum steps --> BFS
h: 1) build a graph where node is index of the arr
   2) for each node, we have three choices:
        1) index + 1
        2) index - 1
        3) index_i to index_j where arr[i]==arr[j]
   3) process like regular BFS until we hit the last index
Note that if we only use BFS to solve, we might encounter a memory limit problem
this is because [7,....,7, 11] if all the numbers are the same except the last one, the graph and queue are huge, so we need to do a compression on original arr, note that
[7,....,7,11] is actually the same as [7,7,11] -- this may be the hard part of this problem
\'\'\'

import collections

class Solution:
    def minJumps(self, arr: List[int]) -> int:
        if len(arr) == 1:
            return 0
        
        if arr[0] == arr[-1]:
            return 1
        
        # compress the original array
        compressedArr = arr[0:2]
        for num in arr[2:]:
            if num == compressedArr[-1] == compressedArr[-2]:
                continue
            compressedArr.append(num)
        arr = compressedArr
        
        indexDic = collections.defaultdict(list)
        for idx, num in enumerate(arr):
            indexDic[num].append(idx)
        
        graph = collections.defaultdict(set)
        for idx, num in enumerate(arr):
            # 1. idx + 1 or idx-1 or both
            if idx == 0:
                graph[idx].add(idx+1)
            elif idx == len(arr)-1:
                graph[idx].add(idx-1)
            else:
                graph[idx].add(idx-1)
                graph[idx].add(idx+1)
            
            # 2. arr[i] == arr[j], i != j
            for v in indexDic[num]:
                if v != idx:
                    graph[idx].add(v)
        
        #print(graph)
        seen = set()
        deque = collections.deque([0])
        steps = 0
        
        while deque:
            size = len(deque)
            for _ in range(size):
                curr = deque.popleft()
                seen.add(curr)
                if curr == len(arr) - 1:
                    return steps # note that we will always hit the last index
                
                for child in graph[curr]:
                    if child not in seen:
                        deque.append(child)
                        seen.add(child)
                
                
            steps += 1   
            #print(deque)