from collections import deque
class Solution:
    def minJumps(self, arr: List[int]) -> int:
        # store all possible jump candidates
        m = {num: [] for num in arr}
        
        for i, num in enumerate(arr):
            # we dismiss all nodes that we could already visit by the other mean of being able to step one up and one down
			# (so if a node had the same value as another and they were bordering, why store it?, 
			# it will not matter and just adds to our unnecessary nodes to visit)
            if 0 < i < len(arr)-1 and arr[i - 1] == num and num == arr[i + 1]:
                continue
            m[num].append(i)
        
        # dont want to revisit the same index
        visited = set()
        
        n = len(arr)
    
        q = deque()
        # add the 0th node in our queue as that is our starting point
        q.append(0)
        res = 0
        while q:
            children = len(q)
			# Here we are currently doing as many iterations as there are nodes in the queue right now
			# The reason being that we do not want to accidentally visit nodes that were not meant to be
			# Visited right now
            for _ in range(children):
                i = q.popleft()
                # don\'t want to revisit the same node
                if i in visited:
                    continue
                # if we reached the end then gg, we won
                if i == n-1:
                    return res
                visited.add(i)
                # can we move one forward?, if we can then let\'s try that
                if (i+1) not in visited:
                    q.append(i+1)
                    
                # can we move one back? if we can then let\'s try that
                if (i-1) not in visited and (i-1) >= 0:
                    q.append(i-1)
                    

                # let\'s add every possible value that has the same value as the current one to our list to visit
                for neighbor in m[arr[i]]:
                    if neighbor in visited:
                        continue
                    q.append(neighbor)
                # No longer need to visit this node\'s partner values ever again, 
                # so let\'s remove all of it\'s partner values. 
                # This also stops the partner nodes from visiting each other again
                # As that is a possibility (You visit all 100s, then when you are visiting
                # the next 100 in your graph, you have to iterate through all 100s again, 
				# that is inefficient so we empty the 100s connections)
                m[arr[i]] = []
            res += 1			
        # if we don\'t get an answer, return -1. Not needed as we are guaranteed an answer but some error checking is a best practice so why not
        return -1