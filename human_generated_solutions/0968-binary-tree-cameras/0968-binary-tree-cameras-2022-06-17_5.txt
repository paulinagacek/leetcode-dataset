# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minCameraCover(self, root: Optional[TreeNode]) -> int:
        hasCamera = False
        isMonitored = False
        # Current root node neither has camera nor it is monitored
        return self.helper(root, hasCamera, isMonitored)

    # Case1: if node has camera-> Then we will add camera at node, return 1 + minimum number of cameras
    # required from left subtree + minimum number of cameras required for right subtree

    # Case2: node doesnt have camera, but is monitored by some child, then we will only
    # need minimum number of cameras required in left subtree + minimum number of cameras
    # required for right subtree

    # Case3: node doesn\'t have camera, and children also doesnt have camera, which means
    # node is not monitored either, So, We will add camera at node and return 1 + minimum
    # number of cameras required in left subtree with minimum number of cameras required in
    # right subtree

    # POINTS TO REMEMBER:-
    # Function will always return minimum number of cameras required for tree, starting from
    # provided node, inititally, we dont know it has camera or not and is monitored or not
    # so we will pass hasCamera and isMonitored as False for every single node, unless,
    # for the case, in which we are adding camera to the node, in that case,
    # left and right node will automatically be monitored, so isMonitored will be true
    # but still, we hasCamera for left and right is False, as left and right can have camera or cannot, it depends
    # Other independent cases, which doesnt depend on whether the node has camera or not or monitored or not are
    # First, we will add the camera at Node
    # Second, we will add camera either at left or right child of the node, as one is enough
    # We are not adding at both because, we are adding camera at our will, going from root node to end nodes or leaf nodes which are null
    # and considering all the possible cases
    # In, the end, we need minimum, of all the three cases

    # Hypothesis -> Will always return the minimum Cameras required
    def helper(self, root, hasCamera, isMonitored) -> int:
        # if no node, then no camera needed
        if root is None:
            return 0
        # ************************** BASE CASES *************************************************
        # now, if node has camera, then we need that camera
        # so we return that camera with minimum cameras in left and right subtree
        # and we will not add camera to the immediate left and right node
        # as they will be monitored by node itself
        if hasCamera:
            # CASE - 1
            return 1 + self.helper(root=root.left, hasCamera=False, isMonitored=True) + self.helper(root=root.right, hasCamera=False, isMonitored=True)

        # no camera is present at node, which means node is monitored somehow
        if isMonitored:
            # This case is tricky, as if node is monitored, then, either we can have cameras
            # at both left or right or only at one of them,
            # in any case we have to find the minimum at both left or right, as our function,
            # returns the minimum number of cameras from the subtree starting from the node
            # CASE - 2
            # No camera at node, but child have camera, so we need cameras from left and right
            childWithCam = self.helper(root.left, hasCamera=False, isMonitored=False) + \\
                self.helper(root.right, hasCamera=False, isMonitored=False)
            childWithNoCam = 1 + self.helper(root.left, hasCamera=False, isMonitored=True) + self.helper(
                root.right, hasCamera=False, isMonitored=True)
            # Now, we dont, need both cases, only the case which has minimum cameras
            return min(childWithCam, childWithNoCam)

        # ************************************* INDUCTION ****************************************
        # Now, all the cases, when adding camera at out will
        # Try, adding camera at node or root
        rootHasCam = 1 + self.helper(root.left, hasCamera=False, isMonitored=True) + \\
            self.helper(root.right, hasCamera=False, isMonitored=True)
        # No camera at root or node
        # Now, we have two cases, either add camera to left or right node
        # First, adding camera to left node
        leftHasCam = float("inf")
        if root.left is not None:
            leftHasCam = self.helper(root.left, hasCamera=True, isMonitored=False) + \\
                self.helper(root.right, hasCamera=False, isMonitored=False)
        # Second, Now adding camera to right node, not left
        rightHasCam = float("inf")
        if root.right is not None:
            rightHasCam = self.helper(root.left, hasCamera=False, isMonitored=False) + \\
                self.helper(root.right, hasCamera=True, isMonitored=False)
        # Now, we want minimum of all the cases
        return min(rootHasCam, leftHasCam, rightHasCam)