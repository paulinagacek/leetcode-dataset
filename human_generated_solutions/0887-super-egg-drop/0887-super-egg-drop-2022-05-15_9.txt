import sys

class Solution:
    def dp(self, n, eggs, lookup):
        key = (n, eggs)
        if key not in lookup:
            if n == 0 or n == 1:
                lookup[key] = n
            elif eggs == 1:
                lookup[key] = n
            else:
                minMoves = sys.maxsize
                """
                    Since 1->n would be always sorted, so we can use binary search instead of linear search to solve this optimally.
                        for i in range(1, n+1):
                            survived = self.dp(n-i, eggs, lookup)
                            notSurvived = self.dp(i-1, eggs-1, lookup)
                            minMoves = min(minMoves, 1+max(survived, notSurvived))
                        lookup[key] = minMoves
                """
                bottom, top = 1, n
                while bottom < top:
                    mid = bottom + ((top - bottom) // 2)
                    survived = self.dp(n - mid, eggs, lookup)
                    notSurvived = self.dp(mid - 1, eggs - 1, lookup)
                    # If egg survived at (mid)th floor then check whether the egg could survive at (mid+1)th floor
                    if survived > notSurvived:
                        bottom = mid + 1
                    else:
                        # If egg didn\'t survive at (mid)th floor then check whether the egg could survive for below floors.
                        top = mid
                    # moves would be 1(move made on current floor) + maximum of (survived, notSurvived).
                    moves = 1 + max(survived, notSurvived)

                    minMoves = min(minMoves, moves)

                lookup[key] = minMoves

        return lookup[key]

    def superEggDrop(self, k: int, n: int) -> int:
        return self.dp(n, k, {})