class Solution:
    def minCut(self, s: str) -> int:
        if not s : return 0
        
        dp = [[True] * len(s) for i in range(len(s))]        # DP Matrix of booleans -> dp[i][j] - TRUE if \'s[i: j + 1]\' is palindrome, else FALSE
        cuts = [float("inf")] * len(s)                       # DP cuts array -> indicates min cuts require till ith entry
        
        # We first find all palindromic substrings
        for r in range(1, len(s)):
            for c in range(len(s) - r):
                if not (s[c] == s[c + r] and dp[c + 1][c + r - 1]):
                    dp[c][c + r] = False

        # For ith column, we check every entry till diagonal element
        # If dp[j][i] is true, implies \'s[j: i + 1]\'\' is palindrome and
        # we check if we get minimum cuts considering this substring or not  
        for i in range(len(s)):
            for j in range(i + 1):
                if dp[j][i]:
                    cuts[i] = min(cuts[i], (cuts[j - 1] + 1) if j - 1 >= 0 else 0)
                    
        return cuts[-1]