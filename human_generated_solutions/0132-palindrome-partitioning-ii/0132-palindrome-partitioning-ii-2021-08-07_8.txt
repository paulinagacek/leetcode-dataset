class Solution:
    def minCut(self, s: str) -> int:
        
        def is_palindrome(string): 
            return string == string[::-1]
        
        dp = [0]*(len(s)+1) #dp[k] will track the minCut of s[:k]
        
        for k in range(1, len(dp)):
            if is_palindrome(s[:k]):
                dp[k] = 0  #so if s[:k] is a palindrome, then we dont need to cut it, hence dp[k] = 0
            
            else:            
                dp[k] = dp[k-1] + 1 #initialize, case s[:k] = s[:k-1] + s[k], we know s[k] will always be a palindrome itself (one letter), so we have 1 split.
                for j in range(k-1, -1, -1):
                    dp[k] = min(dp[k], dp[j] + 1 + int(not(is_palindrome(s[j:k])))*len(s[j:k]))
                    #find the best cut (minimizes the number of cuts), at j, where s[:k] = s[:j] + s[j:k]  (add 1 because 1 cut at position j)
                    #note that if s[j:k] is a palindrome,  int(not(is_palindrome(s[j:k]))) == 0, so we add nothing for this part
                    #when s[j:k] is not a palindrome, int(not(is_palindrome(s[j:k]))) will be 1, we multiply by sth large enough (e.g. len(s[j:k]) or bigger) to "discard" the value

        return dp[-1]