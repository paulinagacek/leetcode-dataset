class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        directions = [(-2, -1), (-1, -2), (1, -2), (2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1)]
        memo = {}
        def dfs(i, j, k):
            if k == 0:
                return 1
            
            if (i, j, k) in memo:
                return memo[(i, j, k)]
            
            p = 0
            for di, dj in directions:
                x = i + di
                y = j + dj
                if x >= 0 and x < n and y >= 0 and y < n:
                    p += dfs(x, y, k - 1) / 8
            
            memo[(i, j, k)] = p
            memo[(n - 1 - i, j, k)] = p
            memo[(i, n - 1 - j, k)] = p
            memo[(n - 1 - i, n - 1 - j, k)] = p
            
            return p
        
       returndfs(row, column, k)