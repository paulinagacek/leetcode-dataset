class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        
        # Build prefix sum table to help us calculate range sum in O(1)
        prefixS = [ nums[0] ]
        for i in range( 1, len(nums) ):
            prefixS.append( prefixS[-1] + nums[i] )
            
        
        
        best = 0            # maximum subarray sum
        start = 0           # left index of sliding window
        summation = 0       # current subarray sum
        
        
        ## dictionary
        # key: number
        # value: latest index of number on the left hand side
        lastIndexOf = defaultdict( lambda : -1)
        
        
        # Sliding windows bounded in [start, end] inclusively
        for end, number in enumerate(nums):
                        
            if lastIndexOf[number] >= start:
                # current number has shown up before
                summation = prefixS[end] - prefixS[ lastIndexOf[number] ]
                start = lastIndexOf[number] + 1
                
            elif start + k == end:
                # current number is unique, but we are forced to discard the leftmost element to keep window size k
                summation = prefixS[end] - prefixS[start]
                start += 1
                
            else:
                # current number is unique, just adding it to summation
                summation += nums[end]
            
            
            if (end - start + 1) == k:
                # Update subarray sum only when window size is k
                best = max(best, summation)
            
            # update lasest index of number
            lastIndexOf[ number ] = end
            
        return best