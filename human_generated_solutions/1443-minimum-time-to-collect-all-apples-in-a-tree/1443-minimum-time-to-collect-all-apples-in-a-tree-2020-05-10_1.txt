Info = collections.namedtuple(\'Info\', (\'found\', \'dist\'))

class Solution:
    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        
        # build an adjacency list to represent the tree using `edges`
        tree = collections.defaultdict(list)
		
		# You don\'t need to make it undirected since the structure represents a tree
        for u, v in edges:
            tree[u].append(v)
        
        # A recursive helper function that find the lowest apple and passes
        # the information (is apple found, distance from the lowest apple to the current node)
        # to the upper node
        
        def traverse(node):
            if node not in tree:
                return Info(hasApple[node], 0)
            curr_dist, apple_found = 0, hasApple[node]
            for child in tree[node]:
                info = traverse(child)
                curr_dist += 2 + info.dist if info.found else 0
                apple_found |= info.found
            return Info(apple_found, curr_dist)
        
        # Get the information from the starting vertex 0
        return traverse(0).dist