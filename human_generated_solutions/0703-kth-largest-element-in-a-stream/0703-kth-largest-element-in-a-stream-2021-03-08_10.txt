"""
Manual binary search/insertion.
"""
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.nums = sorted(nums)        

    def add(self, val: int) -> int:                    
        self.nums.insert(self.search(val), val)
        return self.nums[-self.k]
    
    def search(self, val):        
        lo, hi = 0, len(self.nums)        
        while lo < hi:
            mid = (lo+hi) // 2               
            if self.nums[mid] < val:
                lo = mid+1
            else:
                hi = mid                
        return lo


"""
Using `bisect`
"""
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.nums = sorted(nums)        

    def add(self, val: int) -> int:
        bisect.insort_right(self.nums, val, lo=0, hi=len(self.nums))
        return self.nums[-self.k]      
        

"""
Using `heapq`.
"""
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.heap = nums
        heapq.heapify(self.heap)
        while len(self.heap) > self.k:
            heapq.heappop(self.heap)

    def add(self, val: int) -> int:
        if len(self.heap) < self.k:
            heapq.heappush(self.heap, val)
        elif val > self.heap[0]:
            heapq.heapreplace(self.heap, val)
        return self.heap[0]