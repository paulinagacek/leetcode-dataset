class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        def fun(text1,text2,n,m,dp):

            #in problem in string we have have two option (mathch and not match)
            for i in range(1,n+1):
                for j in range(1,m+1):
                    #match
                    if text1[i-1]==text2[j-1]:
                        (dp[i])[j]=1+ (dp[i-1])[j-1]
                    else:   
                    #not match
                        (dp[i])[j]=max((dp[i-1])[j],(dp[i])[j-1])

            # Now we have dp table in which dp[n][m] represent the length of longest path.
            # Now I have to walk in dp table and have to find the word which is common in both text

            i=n
            j=m
            s=""
            while i>0 and j>0:
                if text1[i-1]==text2[j-1]:
                    s=s+text1[i-1]
                    i-=1
                    j-=1
                elif (dp[i])[j-1] > (dp[i-1])[j]:
                    s=s+text2[j-1]
                    j-=1

                else:
                    s=s+text1[i-1]
                    i-=1


            while i>0:
                s=s+text1[i-1]
                i-=1
            while j>0:
                s=s+text2[j-1]
                j-=1
            return s[::-1]

 
        n=len(str1)
        m=len(str2)
        dp=[[0]*(m+1) for i in range (n+1)]
        return fun(str1,str2,n,m,dp)