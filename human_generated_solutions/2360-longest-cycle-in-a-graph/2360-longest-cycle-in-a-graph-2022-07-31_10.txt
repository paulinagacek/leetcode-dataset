class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        
        #Normal Variable Initialization
        self.res=-1
        visited=set()
        
        def dfs(node,visiting,time):
            
            #Base Case
            #If There is No Outgoing Edge(-1) 
            #This Node Already fully Visited And Cycle is Computed
            #just Return 
            if node==-1 or node in visited:
                return 
            
            #If I Found A Cycle I\'ll Calculate The Time It Initially Discovered
            #And The Current Time
            if node in visiting:
                self.res=max(self.res,time-visiting[node])
                return 
            #otherwise Set The Current Time As Discovered Time Of This Node
            visiting[node]=time
            
            dfs(edges[node],visiting,time+1)
            
            #this is To Take Care To Stop Time Limit Exceeding Error
            #If A Node is Already Visited And Cycle length is Already Computed
            #No Need To Run From That Node Again
            visited.add(node)
            visiting.pop(node)
            
        
        for i in range(len(edges)):
            if i not in visited:
                dfs(i,{},0)
        
        return self.res