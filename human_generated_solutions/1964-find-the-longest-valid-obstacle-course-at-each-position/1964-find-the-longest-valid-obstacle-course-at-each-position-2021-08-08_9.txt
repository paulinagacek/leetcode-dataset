class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        dp = [0 for i in range(len(obstacles))] #stores LIS length up to this element
        l = 1 #current longest LIS so far!
        c = [0 for i in range(len(obstacles)+1)] #the minimum value of the last element of LIS of length i
        #c will contain elements in increasing order
        dp[0] = 1  #The first element is in its own LIS of length 1
        c[1] = obstacles[0]  #The first element is definitely part of an LIS of length 1 at the start
        
        def search(c,l,curr): #binary search algo
            left, right = 0,l
            while left <= right:
                mid = left+(right-left)//2
                if c[mid] > curr: right = mid-1
                else: left = mid+1
            return left
        
        for i in range(1,len(obstacles)):
            curr = obstacles[i] #current obstacle
            if curr < c[1]: #current obstacle is the smallest number we\'ve seen so far
                c[1] = curr
                dp[i] = 1
            elif curr >= c[l]: #can extend the current longest LIS!
                l += 1
                c[l] = curr
                dp[i] = l
            else:  #search for the longest LIS which I can place this current obstacle to the back
                temp = search(c,l,curr)
                c[temp] = curr
                dp[i] = temp
        return dp