class Solution:
    def multiply(self, num1: str, num2: str) -> str:

        # If num1 or num2 is 0, return 0
        if num1 == "0" or num2 == "0":
            return "0"

        # A mapper converting string to int
        nums = {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 3,
            "4": 4,
            "5": 5,
            "6": 6,
            "7": 7,
            "8": 8,
            "9": 9,
        }

        # Find lengths of num1 and num2
        m, n = len(num1), len(num2)

        # Find the maximum group size
        maxSize = min(m, n)

        # Variable to keep track of the carry
        carry = 0

        # Deque used to store the result
        res = deque()

        # First Loop: calcualte all digts from 1 to max group size
        for size, (i, j) in enumerate(
            zip_longest(range(m - 1, -1, -1), range(n - 1, -1, -1), fillvalue=0)
        ):

            # Calculate the current group size capped at max group size
            size = min(size + 1, maxSize)

            # Element wise multiplcation for parts of num1 (start -> end) with parts of num2 (end -> start) and sum the result
            s = (
                sum(
                    nums[num1[a]] * nums[num2[b]]
                    for a, b in zip(range(i, i + size), range(j + size - 1, j - 1, -1))
                )
                + carry
            )

            # Calculate the digit and carry over
            carry, digit = divmod(s, 10)

            # Append the digit into the result
            res.appendleft(str(digit))

        # Second loop: calculate all digits from max group size - 1 to 1
        size = size - 1

        while size > 0:

            # Element wise multiplcation for parts of num1 (start -> end) with parts of num2 (end -> start) and sum the result
            s = (
                sum(
                    nums[num1[a]] * nums[num2[b]]
                    for a, b in zip(range(i, i + size), range(j + size - 1, j - 1, -1))
                )
                + carry
            )

            # Calculate the digit and carry over
            carry, digit = divmod(s, 10)

            # Append the digit into the result
            res.appendleft(str(digit))

            # Decrement the current group size
            size -= 1

        # If there is any carry left, append it to the result
        if carry != 0:
            res.appendleft(str(carry))

        return "".join(res)
