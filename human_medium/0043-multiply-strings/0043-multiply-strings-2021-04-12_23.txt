class Solution:
    # The least significant digits of num1 and num2 are expected to be at position 0.
    def _multiply(self, num1, num2):
        product = [0] * (len(num1) + len(num2))
        for i, multiplier in enumerate(num2):
            carry = 0
            for j, multiplicand in enumerate(num1):
                carry, product[i + j] = divmod(product[i + j] + carry + multiplicand * multiplier, 10)
            product[i + len(num1)] = carry
        return reversed(product if product[-1] > 0 else product[:-1])
    
    def multiply(self, num1: str, num2: str) -> str:
        # This edge case avoids dealing with multiple leading zeros.
        if num1 == "0" or num2 == "0":
            return "0"
        
        return "".join(map(str, self._multiply(tuple(map(int, reversed(num1))), tuple(map(int, reversed(num2))))))
