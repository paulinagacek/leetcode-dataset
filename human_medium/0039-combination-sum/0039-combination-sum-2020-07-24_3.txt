results = []
target_length = 2
arr = [1,2,3]

def combination(i, path):

	# we have found our answer, lets return. Any code below this statement wont get executed and the recursion stops.
	if len(path) == target_length:
		results.append(path[:])
		return

	# With each iteration of the for loop, we will reduce the number of candidates - [1, 2, 3] , [2, 3] , [3]
	# This is important to prevent duplicates. 
	for x in range(i, len(arr)):
		# lets keep adding to path. 	
		path.append(arr[x])

		# lets run combination again, if the path is not our target length, it will go to the for loop again.
	   combination(x, path)

	   # backtrack, remove my last element, so i can move on .
	   path.pop()
   
combination(0, [])

assert combinations == [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]]
