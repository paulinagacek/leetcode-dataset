def cloneGraph(self, node: \'Node\') -> \'Node\':
        
        # Adj list, [[2,4],[1,3],[2,4],[1,3]], means:
        # 1st Node -> [2,4], 2nd Node -> [1,3], 3rd Node -> [2,4], 4th Node -> [1,3]
        
        # The graph consists of only one node with val = 1 and it does not have any neighbors.
        if node is None:
            return None
        
        elif node.val == 1 and node.neighbors == []:
            return Node(val=1)        
        # We shell build a graph. Graph vill be represented by a dict: node_val->node_instance
        graph = {
            1: Node(val=node.val)
        }
            
        # BFS Algorithm
        visited = []
        bfs_queue = []
        
        bfs_queue.append(node)
        visited.append(node.val)
        while len(bfs_queue) != 0:
            curr_node = bfs_queue.pop()
            
            # If node for curr node if doesnt exists - create!
            if curr_node.val not in graph:
                graph[curr_node.val] = Node(val=curr_node.val)
                
            for adj in curr_node.neighbors:
                
                # If node for neighbour if doesnt exists - create!
                if adj.val not in graph:
                    graph[adj.val] = Node(val=adj.val)
                
                if adj.val not in visited:
                    visited.append(adj.val)
                    bfs_queue.insert(0, adj)
                    
                    graph[adj.val].neighbors.append(graph[curr_node.val])
                    # print(f\'visited {adj.val} from {curr_node.val}\')
                    
                else:
                    graph[adj.val].neighbors.append(graph[curr_node.val])
                    # print(f\'visited {adj.val} from {curr_node.val} (goin back)\')
            
        return graph[1] # This is the head node.
