def numTrees(self, n):
        T = [1, 1, 2] + [0]*(n - 2)
        for m in xrange(3, n + 1):
            for i in xrange(m):
                T[m] += T[i] * T[m - 1 - i]
        return T[n]

    """
    Faster version below takes advantage of symmetry (half as many iterations)
    """
    def numTreesFaster(self, n):
        T = [1, 1, 2] + [0]*(n - 2)
        for m in xrange(3, n + 1):
            mid, remainder = divmod(m, 2)
            for i in xrange(mid):
                T[m] += T[i] * T[m - 1 - i]
            T[m] *= 2
            if remainder: T[m] += T[mid] * T[mid]
        return T[n]
