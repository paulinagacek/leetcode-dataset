class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums: return 0
        
        # To make the algorithm O(n) we need to do path compression for the disjoint set
        disjoint_set = {}
        
        # We need a separate rank hashmap, because representing ranks with negative number is impossible when negative values are present in array
        ranks = {}
        answer = 1
        
        for n in nums:
            # skip duplicate values
            if n in disjoint_set: continue
            
            # Start as a component with 1 rank
            ranks[n] = 1
            disjoint_set[n] = n
            
            
            # Append higher values to current node
            if n+1 in disjoint_set:
                ranks[n] += ranks[n+1]
                ranks[n+1] = 0
                disjoint_set[n+1] = n
                
                answer = max(answer, ranks[n])
            
            if n-1 in disjoint_set:
                # n-1 node could be root or point to some other node, example: (n=5, n-1 = 4) 4->3->2
                root = self.union_find_with_compression(disjoint_set, n-1)
                ranks[root] += ranks[n]
                ranks[n] = 0
                disjoint_set[n] = root
                
                answer = max(answer, ranks[root])
        
        return answer
    

    def union_find_with_compression(self, disjoint_set, node):
        if disjoint_set[node] == node:
            return node
        
        root = self.union_find_with_compression(disjoint_set, disjoint_set[node])
        disjoint_set[node] = root
        
        return root
