def findOrder(self, numCourses: int, pres: List[List[int]]) -> List[int]:
        # make an adjacency map
        preMap = {c:[] for c in range(numCourses)}
        for course,pre in pres:
            preMap[course].append(pre)
        
        visited = set()
        ancestor = set() # should be like a global var
        order = []
        #dfs
        def dfs(course):
            ancestor.add(course)
            visited.add(course)
            for pre in preMap[course]:
                if pre in ancestor: # ancestor include current course and its all parents
                    return False
                elif pre not in visited:
                    if not dfs(pre): return False # False if atleast on pre req fails
            ancestor.remove(course) # backtracking 
            order.append(course) # save the course order
            return True # True only if all pre req of current course is True

        for course in preMap.keys():
            if course not in visited:
                if not dfs(course) : return []
        return order
		# like if you find it helpful
