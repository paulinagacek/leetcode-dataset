class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root: return

        prev = None
        stack = [root]
        while stack:
            node = stack.pop()
            if node.right: stack.append(node.right)
            if node.left: stack.append(node.left)
            if prev:
                prev.left = None
                prev.right = node
            prev = node
    # iterative dfs
    # O(n)
    # O(log n) if balanced O(n) if singly linked

    def flatten(self, root: Optional[TreeNode]) -> None:
        if not root: return

        node = root
        while node:
            if node.left: # move left child to right
                rightMost = node.left
                while rightMost.right: # find first child without right
                    rightMost = rightMost.right
                rightMost.right = node.right # still keeps the same pre order
                node.right = node.left
                node.left = None
            node = node.right
    # O(n) time
    # O(1) space
