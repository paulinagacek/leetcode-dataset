class Solution:
    def flatten_inplace(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
		# iterative in-place solution
        node = root
        while node:
            print(node.val)
            if node.left:
                tmp  = node.right
                node.right = node.left
                if not node.right.right:
                    node.right.right = tmp
                else:
                    right_ptr = node.right
                    while right_ptr.right != None:
                        right_ptr = right_ptr.right
                    right_ptr.right =tmp
                node.left = None
            node = node.right
            
    def flatten_stack(self, root: TreeNode) -> None:
	# iterative stack pre-order traverse, fastest
        
        lst = []
        stack = [root]
        while stack != []:
            node = stack[-1]
            stack = stack[:-1]
            if node:
                lst.append(node)
                stack.append(node.right)
                #stack.append(node)
                stack.append(node.left)

        for i in range(1, len(lst)):
            lst[i-1].right = lst[i]
            lst[i-1].left = None
            
    def flatten(self, root: TreeNode) -> None:
	# recursive solution
        if not root:
            return 
        
        l, r = root.left, root.right
        root.left, root.right = None, l
        
        self.flatten(l)
        
        while root.right:
            root = root.right
        root.right = r
        self.flatten(r)
