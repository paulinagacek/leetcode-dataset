def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        
        output = []        
        visited = set()
        
        def backtrack(currentList):
            
            # this caches visited nodes so we don\'t go down duplicated recursion tree paths
            if tuple(currentList) in visited:
                return
            else:
                visited.add(tuple(currentList))
            
            
            # base case
            if len(currentList)==len(nums):

                # when these conditions are met, add it to output
                if sorted(currentList)==sorted(nums) and currentList not in output:
                    output.append(currentList.copy())

                return

            #  going down the recursion tree (similar to permutation 1 but without duplicate check)
            for i in range(0, len(nums)):

                currentList.append(nums[i])
                backtrack(currentList)
                currentList.pop()
        
        backtrack([])
        return output
