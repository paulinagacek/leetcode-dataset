def solve(self, board: List[List[str]]) -> None:
        """
        Approach: 
        iterate over borders and identify the cell having O
        start the dfs from there and capture all the indexes you can
        visit starting from there having O. (those are the indexes that won\'t change)
        once you have the list of all indexes, update the remaining cells with O to X
        """
        m, n = len(board), len(board[0])
        def is_valid(i, j):
            if 0 <= i < m and 0 <= j < n:
                return True
            return False
        
        def get_neighbors(i, j):
            return [(i+1,j), (i-1,j), (i,j-1), (i,j+1)]
        
        def dfs(i,j):
            visited.add((i,j))
            for x,y in get_neighbors(i,j):
                if is_valid(x, y) and board[x][y] == \'O\' and (x,y) not in visited:
                    dfs(x, y)
                    
        visited = set() 
        for i in range(m):
            if board[i][0] == \'O\':
                dfs(i, 0)
            if board[i][-1] == \'O\':
                dfs(i, n-1)
                
        for i in range(n):
            if board[0][i] == \'O\':
                dfs(0, i)
            if board[-1][i] == \'O\':
                dfs(m-1, i)
        
        for i in range(m):
            for j in range(n):
                if board[i][j] == \'O\' and (i,j) not in visited:
                    board[i][j] = \'X\'
        return board
