class Solution(object):
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """
        if n == 0:
            return []
        
        res = [[None]]
        
        # left_tree_res*right_tree_res
        # dp[1] = dp[0]*dp[0](root:1)
        # dp[2] = dp[0]*dp[1](root:1) + dp[1]*dp[0](root:2)
        # dp[3] = dp[0]*dp[2](root:1) + dp[1]*dp[1](root:2) + dp[2]*dp[0](root:3)
        # dp[k] = dp[0]*dp[k-1](root:1) + ... dp[i]*dp[k-1-i](root:i+1) + ... dp[k-1]*dp[0](root:k)
        for x in range(1, n+1):
            res.append([])
            for i in range(0, x):
                left_set = res[i]
                right_set = res[x-1-i]
                for left in left_set:
                    for right in right_set:
                        # root value will always be i+1
                        root = TreeNode(i+1)
                        # left tree no need to adjust anything since it\'s a UBST of 1 to i
                        root.left = copy_tree(left, 0)
                        # right tree need to add i+1 to all nodes
                        root.right = copy_tree(right, i+1)
                        res[x].append(root)
        return res[n]

# Helper function to copy a tree and append same value to all nodes
def copy_tree(node, val):
    if node is None:
        return None
    root = TreeNode(node.val + val)
    if node.left is not None:
        root.left = copy_tree(node.left, val)
    if node.right is not None:
        root.right = copy_tree(node.right, val)
    return root
