class Solution(object):
    def fourSum(self, nums, target):
        """
        First sort the array, then loop over the first two indices i & j, and use twoSum to find
        k and l such that nums[k] + nums[l] = target - nums[i] - nums[j]. We always enforce i < j < k < l.
        """
        result, result_set, dic, nums = [], set(), {}, sorted(nums)
        self.initDic(nums, dic)
        for i in range(len(nums) - 3):
            for j in range(i + 1, len(nums) - 2):
                for (k, l) in self.twoSums(nums, dic, target - nums[i] - nums[j], j + 1):
                    if (nums[i], nums[j], nums[k], nums[l]) not in result_set:  # Check for duplicates.
                        result.append([nums[i], nums[j], nums[k], nums[l]])
                        result_set.add((nums[i], nums[j], nums[k], nums[l]))
        return result

    def initDic(self, nums, dic):
        """
        Initiate a dict used by twoSums containing (start, end) tuples for indices containing each value in nums.
        """
        for k in range(2, len(nums)):
            if nums[k] not in dic:
                dic[nums[k]] = (k, k)  # Store (start, end) range of indices containing nums[k].
            else:
                dic[nums[k]] = (dic[nums[k]][0], k)  # Update end value only.

    def twoSums(self, nums, dic, target, min_k):
        """
        Similar to https://leetcode.com/articles/two-sum/ "Approach 2: Two-pass Hash Table"
        """
        result = []
        for k in range(min_k, len(nums) - 1):
            (start, end) = dic.get(target - nums[k], (None, None))
            if start is not None:
                for l in range(max(start, k + 1), end + 1):
                    result.append((k, l))
        return result
