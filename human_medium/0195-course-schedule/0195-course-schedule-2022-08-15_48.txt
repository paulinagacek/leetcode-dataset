class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        adj = {}
        
        """
        in_degree of any course/node represents no. of courses/nodes on which specific
        node depends
        """
        in_degree= [0]*numCourses
        
        for i,j in prerequisites:
            if not adj.get(j):
                adj[j]= [i]
            else:
                adj[j].append(i)
            in_degree[i]+=1
        for i in range(numCourses):
            if not adj.get(i):
                adj[i]=[]
        
        """
        place all those courses in queue who are not dependent on any course
        (nodes whose in_degree is 0)
        """
        q=[i for i in range(len(in_degree)) if in_degree[i]==0]
        topo_sort= []
        
        while q:
            front = q[0]
            topo_sort.append(front)
            q.pop(0)
            
            for node in adj[front]:
                """
                as we complete one course, remove it\'s dependency on other courses
                (reduce in_degree of nodes by 1 which are adjacent to current node,
                as we have traversed it)
                """
                in_degree[node]-=1
                
                """
                if any course has no dependency from any other course, take the course
                (add the node to queue whose in_degree becomes 0)
                """
                if in_degree[node]==0:
                    q.append(node)
        
        """
        if len(topo_sort) is not equal to total no. of courses, it implies that there is 
        circular dependency of courses.
        (there is cycle in graph, so return False)
        """
        if len(topo_sort)==numCourses:
            return True
        return False
