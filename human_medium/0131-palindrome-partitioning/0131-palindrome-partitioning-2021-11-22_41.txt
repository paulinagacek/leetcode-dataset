class Solution:
    def partition(self, s: str) -> List[List[str]]:
        
        # Init
        output = []
        part = []
        n = len(s)
        
        # Helper function to check palindrome
        def isPalindrome(low,high):
            x = s[low:high+1]
            r = x[::-1]
            return x == r
        
        # Recursion with backTacking
        def search(i):
            
            # Store the current partioning if the string is exhausted
            if i == n:
                output.append(part.copy())
            else:
                
                # Look for all the indexes starting from i
                for j in range(i, n):
                    
                    # Check if the string is plaindrome
                    # betweem index i and j, if yes,
                    # add it to current partition
                    if isPalindrome(i, j):
                        
                        part.append(s[i:j+1]) # add
                        search(j+1) # seach partitions starting next index
                        part.pop() # backtack
                        
        search(0) # search planindrome starting 0th index
        
        return output
