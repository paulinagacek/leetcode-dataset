class Solution:

    # Credits: @anderson5
    # O(min(len(word1), len(word2))^3) time | O(min(len(word1), len(word2))^3) space
    def minDistance(self, word1: str, word2: str) -> int:
        # if both words are empty, we are done
        if not word1 and not word2:
            return 0
        # if word1 is empty, then we have to insert the rest of word1
        if not word1:
            return len(word2)
        # if word2 is empty, then we have to delete the rest of word1
        if not word2:
            return len(word1)
        # if the chars are the same, then 0 distance is added
        if word1[0] == word2[0]:
            return self.minDistance(word1[1:], word2[1:])
        # Insert the char word2[0] in the beginning of word1
        insert = self.minDistance(word1, word2[1:])
        # delete word1[0], it doesn\'t captures any char of word2
        delete = self.minDistance(word1[1:], word2)
        # replace word1[0] w/ word2[0]
        replace = self.minDistance(word1[1:], word2[1:])
        # return the operations the gives us the least distance
        # +1 because each of the above count as action
        return 1 + min(insert, replace, delete)
    
    # O(min(len(word1), len(word2))^3) time | O(min(len(word1), len(word2))^3) space
    def minDistance(self, word1: str, word2: str) -> int:
        
        def dp(i: int, j: int):
            if i == len(word1) and j == len(word2):
                return 0
            if i == len(word1):
                return len(word2) - j
            if j == len(word2):
                return len(word1) - i
            if word1[i] == word2[j]:
                return dp(i + 1, j + 1)
            insert = dp(i, j + 1)
            delete = dp(i + 1, j)
            replace = dp(i + 1, j + 1)
            return 1 + min(insert, delete, replace)

        return dp(0, 0)
    
    # O(min(len(word1), len(word2))) time | O(min(len(word1), len(word2))) space
    def minDistance(self, word1: str, word2: str) -> int:

        def dp(i: int, j: int):
            if i == len(word1) and j == len(word2):
                return 0
            if i == len(word1):
                return len(word2) - j
            if j == len(word2):
                return len(word1) - i
            if word1[i] == word2[j]:
                return dp(i + 1, j + 1)
            
            if (i, j) not in memo:
                insert = dp(i, j + 1)
                delete = dp(i + 1, j)
                replace = dp(i + 1, j + 1)
                memo[(i, j)] = 1 + min(insert, delete, replace)
            
            return memo[(i, j)]

        memo = {}
        return dp(0, 0)

    # O(min(len(word1), len(word2))) time | O(min(len(word1), len(word2))) space
    def minDistance(self, word1: str, word2: str) -> int:
        
        @cache
        def dp(i: int, j: int):
            if i == len(word1) and j == len(word2):
                return 0
            if i == len(word1):
                return len(word2) - j
            if j == len(word2):
                return len(word1) - i
            if word1[i] == word2[j]:
                return dp(i + 1, j + 1)
            insert = dp(i, j + 1)
            delete = dp(i + 1, j)
            replace = dp(i + 1, j + 1)
            return 1 + min(insert, delete, replace)

        return dp(0, 0)
    
    # O(nm) time | O(min(nm) space
    def minDistance(self, word1, word2):
        m, n = len(word1), len(word2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j

        for i in range(1, m + 1):
            for j in range(1, n + 1):                            
                dp[i][j] = dp[i - 1][j - 1] if word1[i - 1] == word2[j - 1] \\
                    else 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
        return dp[-1][-1]

    # O(min(len(word1), len(word2))) time | O(min(len(word1), len(word2))) space
    def minDistance(self, word1: str, word2: str) -> int:
        
        @cache
        def dp(i: int, j: int):
            if i == len(word1) and j == len(word2):
                return 0
            if i == len(word1):
                return len(word2) - j
            if j == len(word2):
                return len(word1) - i
            if word1[i] == word2[j]:
                return dp(i + 1, j + 1)            
            return 1 + min(dp(i, j + 1), dp(i + 1, j), dp(i + 1, j + 1))

        return dp(0, 0)
