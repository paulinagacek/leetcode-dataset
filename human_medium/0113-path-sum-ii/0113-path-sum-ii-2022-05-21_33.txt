class Solution:
    
    # PATTERN: DEPTH FIRST SEARCH (DFS)
    # This problem follows the Binary Tree Path Sum II pattern. We can follow the same DFS approach. There will be two differences:
        # - Every time we find a root-to-leaf path, we will store it in a list.
        # - We will traverse all paths and will not stop processing after finding the first path.
        
    # Here are the steps for our Binary Tree Path Sum problem:
        # 1) Start DFS with the root of the tree.
        # 2) If the current node is not a leaf node, do two things:
            # - Subtract the value of the current node from the given number to get a new target sum => S = S - node.value
            # - Make two recursive calls for both the children of the current node with the new number calculated in the previous step.
        # 5) At every step, see if the current node being visited is a leaf node and if its value is equal to the given number \u2018S\u2019. If both these conditions are true, we have found the required root-to-leaf path, therefore return true.
        # 6) If the current node is a leaf but its value is not equal to the given number \u2018S\u2019, return false.
        
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        
        # 1st OF 5 LINES CHANGED FROM \'Leetcode #112: Path Sum\'.
        # instead of performing the recursive DFS inside of this main function, we call another helper function \'find_paths_recursively\'. this is because our recursive functions must add to, pass on, and delete from a list variable, but this current function only takes a \'root\' node and \'targetSum\' as input variables.
        # we will pass on a \'allPaths\' variable to the helper function for it to populate with all valid paths. the helper function also requires an aditional list variable to pass on within calls of itself, but we don\'t need that information here, so we will simply pass on an empty list as a function argument
        allPaths = []  # list to hold all valid paths
        
        self.find_paths_recursively(root, targetSum, [], allPaths)  # recursive helper function call
        
        return allPaths
        
    
    def find_paths_recursively(self, currentNode, requiredSum, currentPath, allPaths):
        
        if (currentNode is None):
            # This \'if\' statement takes care of two situations:
            # (i) Base case where the \'root\' we were given has 0 nodes
            # (ii) 6. If the current node is a leaf but its value is not equal to \u2018target_sum\u2019, we return false.
            # Note: case (i) is a special case of (ii). In recursion, we keep calling this function inside itself and in each iteration we pass a \'root\' value. If the previous node was a leaf and we called the function with its \'left\' and \'right\', both of these would be \'None\' so we are calling the function with \'root = None\', which is case (i). We return \'nothing\' to end the current recursion loop because we have reached the leaf (before the last time calling the function with leaf\'s \'left\' and \'right\') and it did not result in a path that equals \'targetSum\'
            return
			
        # 2nd OF 5  LINES CHANGED FROM \'Leetcode #112: Path Sum\'
        # add the current_node to the current path\'s list
        currentPath.append(currentNode.val)
        
        # 5. Check if the current node being visited is a lead nore and if its value is equal to the given targetSum
        if (currentNode.val == requiredSum) and (currentNode.left is None) and (currentNode.right is None):
            # if all these conditions are true, we have found the required sum path, therefore return true.
            # 3rd OF 5  LINES CHANGED FROM \'Leetcode #112: Path Sum\'
            # instead of simply returning \'true\' like in #112, add the currentPath to the allPaths list
            allPaths.append(list(currentPath))  # remember to add the \'currentPath\' list as list or it will only add the numbers to \'allPaths\' whereas we want to store it as a list to separate from other answers
        
        # 2. If the current node is not a leaf node, do two things:
            # - Subtract the value of the current node from the given number to get a new target sum => S = S - node.value
            # - Make two recursive calls for both the children of the current node with the new number calculated in the previous step.
        # 4th OF 5  LINES CHANGED FROM \'Leetcode #112: Path Sum\'. instead of returning our recursive calls, we will simply do the recursive calls because we don\'t need our recursive calls to return anything inside of the current function. we just make changes to the list we were passed from the main \'pathSum\' function and this main function will return the final list when this function finishes
        # traverse the left sub-tree
        self.find_paths_recursively(currentNode.left, requiredSum -
                         currentNode.val, currentPath, allPaths)
        # traverse the right sub-tree
        self.find_paths_recursively(currentNode.right, requiredSum -
                         currentNode.val, currentPath, allPaths)
        
        # 5th OF 5  LINES CHANGED FROM \'Leetcode #112: Path Sum\'
        # remove the current node from the path to backtrack,
        # we need to remove the current node while we are going up the recursive call stack.
        del currentPath[-1]
    

    
    # Time Complexity: The time complexity of the above algorithm is O(N^2), where N are the number of nodes in a tree. In the worst case, we could have a complete binary tree and if that is the case, then there would be N/2 leafs. For every leaf, we perform a potential O(N) operation of copying over the pathNodes nodes to a new list to be added to the final pathsList. Hence, the complexity in the worst case could be O(N^2).

    # Space Complexity: The space complexity of the above algorithm will be up to O(H), where H is the binary tree height. This space will be used to store the recursion stack. In the worst case, the space complexity will be O(N). The worst case will happen when the given tree is a linked list (i.e., every node has only one child).
