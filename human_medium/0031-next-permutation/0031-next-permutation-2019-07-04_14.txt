class Solution(object):
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        card = len(nums)
        
        for k in range(card-1):             # check if a greater arrangement is not possible
            if nums[k] < nums[k+1]:
                break
        else:
            nums.reverse()                  # if it\'s not possible - reverse sequence and stop
            return

        for i in range(card - 1, 0, -1):    # card-1, card-2, card-3, ..., 2, 1
            if nums[i] > nums[i - 1]:       # from the end of sequence find the first decreasing element (\'nums[i-1]\')
                low = nums[i]
                
                # among afterward digits (nums[i]...nums[card-1]) we find the smallest digit (\'low\') that is bigger then \'nums[i-1]\'
                for n in range(i+1, card):  
                    if nums[i-1] < nums[n] < low:
                        low = nums[n]

                low_index = nums.index(low, i) 
                nums[i - 1], nums[low_index] = nums[low_index], nums[i - 1]  # swap \'nums[i-1]\' and \'low\' in a sequence
            
                for iter_num in range(card-1, i, -1):  # sort afterward digits (nums[i]...nums[card-1])
                    for idx in range(i, iter_num):     # PS: this is Bubble Sort algorithm, but you can choose smth faster
                        if nums[idx] > nums[idx + 1]:
                            nums[idx + 1], nums[idx] = nums[idx], nums[idx + 1]
                break                                  # STOP
