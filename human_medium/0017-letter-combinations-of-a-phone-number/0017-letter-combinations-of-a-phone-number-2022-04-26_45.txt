class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: return []
        dictionary = {\'2\' : [\'a\', \'b\', \'c\'], \'3\' : [\'d\', \'e\', \'f\'], \'4\' : [\'g\', \'h\', \'i\'], 
                        \'5\' : [\'j\', \'k\', \'l\'], \'6\' : [\'m\', \'n\', \'o\'], \'7\' : [\'p\', \'q\', \'r\', \'s\'], \'8\' : [\'t\', \'u\', \'v\'], \'9\' : [\'w\',\'x\', \'y\', \'z\']}
        self.dic = dictionary
        self.solution = []
        self.sol(list(digits), "", len(digits))
        return self.solution
    
    def sol(self, digits, s, size):
            if len(s) == size: # append only in the right moment when string size is equal to the number of digits.
                self.solution.append(s)
            if not digits: return 0 # dont go further in the recursion.               
            for digit in digits:
                temp = digits[:] # copying the list.
                temp.remove(digit) # removing the digit, letters are unique.  
                for letter in self.dic[digit]:
                    self.sol(temp, s + letter, size)
                return 0 # return to break, before taking all combinations.
