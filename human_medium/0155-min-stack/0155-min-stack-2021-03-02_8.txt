#The idea here is to keep track of min element using a seperate stack.
#without the additional stack of min elements, we will have to traverse the entire stack and it will not be constant time,
#As there is no constraint for spacer complexity, we will user additional data strcuture.
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack =[] #main stack
        self.min=[]  #To keep track of minimum element in the stack
                

    def push(self, x: int) -> None:                
            #Push all into the main stack.
            self.stack.append(x)  
            
            # If min stack present. Check the top element of min stack. 
            # If X is less than top-element, append into the min stack. 
            # It will ensure that top element is always minimum.
            if self.min: 
                # Compare and push into min stack only if new element is 
                # smaller than top element of min stack.
                if x <= self.min[-1]: 
                    self.min.append(x)
            else:
                self.min.append(x)  

    def pop(self) -> None:
            #Remove and return the top element.
            #Assigning it to a variable to compare if the popped out value is same as min\'s top element. 
            #if its same, pop from min stack as well.
            check= self.stack.pop() 
            if check == self.min[-1]:
                self.min.pop()
                
    def top(self) -> int:
            if self.stack: 
                return self.stack[-1] #Read and return the top element from mainstack.


    
    def getMin(self) -> int:
        if self.stack: 
            return self.min[-1] #Read and return the top element from min stack.
