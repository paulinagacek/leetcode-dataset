class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        l=0
        r=len(nums)-1
        while l<=r:
            mid=(l+r)//2
            if nums[mid]==target:
                return mid
            if nums[l]<=nums[mid]:
                if target>=nums[l] and target<=nums[mid]:
                    r=mid-1
                else:
                    l=mid+1
            else:
                if target>nums[mid] and target<=nums[r]:
                    l=mid+1
                else:
                    r=mid-1
        return -1
        
#SUBMISSION REPORT:-
    # Runtime: 51 ms, faster than 27.66% of Python online submissions for Search in Rotated Sorted Array.
    # Memory Usage: 13.7 MB, less than 65.21% of Python online submissions for Search in Rotated Sorted Array.
    
#EXPLANATION:-
    # First we take two pointer l and r for doing a (modified) binary search
    # We run a while loop till l is less than or equal to r
    # We initialize our mid variable
    # We return mid if it is equal to target
    # We check if the value of nums[l] is less than equal to nums[mid], if it is then it means that the array is sorted on the left side
    # Else array is sorted on the right side
    # If array is sorted on left, we check whether target lies in that domain, if it does, we check for it in the LEFT square, else in the RIGHT square
    # Else, if the array is sorted on right, we check whether target lies in that domain, if it does, we check for it in ther RIGHT square, else in the LEFT square
