# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        # Initialize two nodes that will hold the two elements to be swapped
        first, second = None, None
        
        # This stack is used for inorder traversal
        stack = []
        
        # Pointer to track the previous node in the in-order traversal
        prev = TreeNode(float('-inf'))
        
        while root or stack:
            # Reach the leftmost node of the current node
            while root:
                stack.append(root)
                root = root.left
            
            # Backtrack from the empty stack
            root = stack.pop()
            
            # If this node's value is less than the previous node's value, we've found an inversion
            if prev.val > root.val:
                second = root  # This is the second node in the pair to be swapped
                if first is None:
                    first = prev  # This is the first node in the pair to be swapped
                else:
                    break
            
            # Update the previous node and move on to the right subtree
            prev = root
            root = root.right
        
        # Swap the values of the two nodes
        first.val, second.val = second.val, first.val
