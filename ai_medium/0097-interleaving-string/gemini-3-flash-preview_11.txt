class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        n, m = len(s1), len(s2)
        
        # The total length of s1 and s2 must equal the length of s3
        if n + m != len(s3):
            return False
        
        # Follow-up: O(s2.length) additional space
        # dp[j] will represent whether s3[0:i+j] can be formed by 
        # interleaving s1[0:i] and s2[0:j]
        dp = [False] * (m + 1)
        
        # Base case: empty s1 and s2 can form empty s3
        dp[0] = True
        
        # Initialize the first row (interleaving s2 with an empty s1)
        for j in range(1, m + 1):
            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]
            
        # Process each row (characters from s1)
        for i in range(1, n + 1):
            # Update the first column of the current row (interleaving s1 with an empty s2)
            # dp[0] currently holds the value for dp[i-1][0]
            dp[0] = dp[0] and s1[i-1] == s3[i-1]
            
            for j in range(1, m + 1):
                # We can reach the current state dp[i][j] from:
                # 1. dp[i-1][j] (current dp[j]) if the i-th char of s1 matches s3
                # 2. dp[i][j-1] (updated dp[j-1]) if the j-th char of s2 matches s3
                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])
                
        return dp[m]
