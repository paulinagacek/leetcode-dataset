class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        n, m, l = len(s1), len(s2), len(s3)
        
        # If the combined length of s1 and s2 does not match s3, they cannot interleave.
        if n + m != l:
            return False
        
        # Space-optimized DP table using a 1D array of size m + 1.
        # dp[j] will store whether s3[0 : i+j] can be formed by s1[0 : i] and s2[0 : j].
        dp = [False] * (m + 1)
        
        # Base case: empty s1 and empty s2 form empty s3.
        dp[0] = True
        
        # Initial condition for the first row (i = 0, representing s1 is empty).
        for j in range(1, m + 1):
            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]
            
        # Transition for i > 0.
        for i in range(1, n + 1):
            # Update dp[0] for the new row i (representing s2 is empty).
            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]
            
            for j in range(1, m + 1):
                # The current dp[j] (from the previous i) represents dp[i-1][j].
                # dp[j-1] (from the current i loop) represents dp[i][j-1].
                # dp[j] becomes True if we can use s1[i-1] or s2[j-1] to match s3[i+j-1].
                use_s1 = dp[j] and s1[i - 1] == s3[i + j - 1]
                use_s2 = dp[j - 1] and s2[j - 1] == s3[i + j - 1]
                dp[j] = use_s1 or use_s2
                
        return dp[m]
