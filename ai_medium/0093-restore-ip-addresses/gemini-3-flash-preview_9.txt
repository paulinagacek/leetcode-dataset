class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        n = len(s)
        # An IP address must have between 4 and 12 digits inclusive.
        if n < 4 or n > 12:
            return []
        
        res = []
        
        def backtrack(start: int, path: List[str]):
            # Base case: if we have found 4 segments
            if len(path) == 4:
                # If we have used all characters from the string s
                if start == n:
                    res.append(".".join(path))
                return
            
            # Pruning: calculate how many segments are left to fill
            remaining_slots = 4 - len(path)
            # If the remaining characters in s cannot fit into the remaining slots
            # (either too few or too many), stop this recursion branch.
            if (n - start) > remaining_slots * 3 or (n - start) < remaining_slots:
                return

            # Try to extract a segment of length 1, 2, or 3
            for length in range(1, 4):
                # Ensure we don't go past the end of the string
                if start + length > n:
                    break
                
                segment = s[start:start+length]
                
                # Validation: check for leading zeros. 
                # A multi-digit segment cannot start with '0'.
                if length > 1 and segment[0] == '0':
                    # If the segment starts with '0' and length > 1, 
                    # any longer length segment starting at this index is also invalid.
                    break
                
                # Validation: each segment must be between 0 and 255.
                if int(segment) <= 255:
                    path.append(segment)
                    backtrack(start + length, path)
                    path.pop()
                    
        backtrack(0, [])
        return res
