class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        n = len(s)
        
        # A valid IP address must have between 4 and 12 digits
        if n < 4 or n > 12:
            return []
        
        def backtrack(start: int, parts: List[str]):
            # Base case: if we have found 4 parts
            if len(parts) == 4:
                # If we have used all digits in s, we found a valid IP
                if start == n:
                    res.append(".".join(parts))
                return
            
            # Each part can have 1, 2, or 3 digits
            for length in range(1, 4):
                # Ensure we don't go out of bounds
                if start + length > n:
                    break
                
                segment = s[start : start + length]
                
                # Check for leading zeros: "0" is valid, but "01", "001" are not
                if len(segment) > 1 and segment[0] == '0':
                    continue
                
                # Check if the segment is within the valid range [0, 255]
                if int(segment) > 255:
                    continue
                
                # Optimization: if the remaining digits are too many or too few for the remaining parts
                remaining_digits = n - (start + length)
                remaining_parts = 3 - len(parts)
                if remaining_digits < remaining_parts or remaining_digits > remaining_parts * 3:
                    continue
                
                backtrack(start + length, parts + [segment])
        
        backtrack(0, [])
        return res
