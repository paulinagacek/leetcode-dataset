class Solution:
    def reverse(self, x: int) -> int:
        # Define the 32-bit signed integer range limits
        MAX_INT = 2147483647
        MIN_INT = -2147483648
        
        res = 0
        while x != 0:
            # Get the last digit. Python's % operator behaves differently for 
            # negative numbers, so we handle them specifically to mimic 
            # truncation toward zero (like in C++ or Java).
            if x < 0:
                # For x = -123, pop becomes -3
                pop = x % -10
                # Truncate toward zero: int(-123 / 10) becomes -12
                x = int(x / 10)
            else:
                pop = x % 10
                x //= 10
            
            # Check for overflow before updating res. 
            # MAX_INT // 10 is 214748364.
            if res > 214748364 or (res == 214748364 and pop > 7):
                return 0
            # MIN_INT // 10 is -214748364 (using truncation toward zero).
            if res < -214748364 or (res == -214748364 and pop < -8):
                return 0
            
            # Since the environment does not allow 64-bit integers,
            # we ensure res stays within 32-bit range before performing the operation.
            res = res * 10 + pop
            
        return res
