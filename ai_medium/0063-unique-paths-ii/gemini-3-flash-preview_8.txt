class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        # Get the dimensions of the grid
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        
        # Initialize a 1D DP array to store the number of ways to reach each column
        # dp[j] represents the number of unique paths to reach the current cell in column j
        dp = [0] * n
        
        # Base case: if the starting cell is not an obstacle, there's 1 way to be there
        dp[0] = 1
        
        # Iterate through each row of the grid
        for i in range(m):
            for j in range(n):
                # If the current cell is an obstacle, it cannot be reached
                if obstacleGrid[i][j] == 1:
                    dp[j] = 0
                # If the cell is not an obstacle and not in the first column,
                # the number of ways to reach it is the sum of ways from above and from the left
                # dp[j] currently holds the value from the previous row (above)
                # dp[j-1] holds the value from the current row (left)
                elif j > 0:
                    dp[j] += dp[j - 1]
                # If it's the first column (j=0) and not an obstacle, 
                # dp[0] remains its value from the previous row
        
        # Return the number of unique paths to reach the bottom-right corner
        return dp[n - 1]
