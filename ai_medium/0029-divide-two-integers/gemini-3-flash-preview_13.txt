class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        # Define limits for 32-bit signed integers
        INT_MIN = -2147483648
        INT_MAX = 2147483647
        
        # Handle the specific overflow case mentioned in the problem
        if dividend == INT_MIN and divisor == -1:
            return INT_MAX
        
        # Determine the sign of the result
        # The result is negative if dividend and divisor have different signs
        negative = (dividend < 0) != (divisor < 0)
        
        # Work with positive values for easier logic
        # Python handles arbitrary precision, so abs(INT_MIN) won't overflow
        a, b = abs(dividend), abs(divisor)
        quotient = 0
        
        # Use bit manipulation (binary long division) to achieve O(log N) time
        # This approach effectively subtracts multiples of the divisor:
        # divisor * 2^n, divisor * 2^(n-1), ..., divisor * 2^0
        while a >= b:
            temp_divisor, count = b, 1
            # Find the largest power of 2 such that (divisor * 2^count) <= a
            while a >= (temp_divisor << 1):
                temp_divisor <<= 1
                count <<= 1
            
            # Subtract the largest power of 2 multiple from the current dividend
            a -= temp_divisor
            # Add the corresponding power of 2 to the quotient
            quotient += count
        
        # Apply the determined sign to the quotient
        res = -quotient if negative else quotient
        
        # Clamp the result within the 32-bit signed integer range
        if res < INT_MIN:
            return INT_MIN
        if res > INT_MAX:
            return INT_MAX
            
        return res
