class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        # Get the total length of the linked list
        length, curr = 0, head
        while curr:
            length += 1
            curr = curr.next
        
        # Iterative Merge Sort (Bottom-up approach) for O(1) space
        dummy = ListNode(0, head)
        step = 1
        while step < length:
            prev, curr = dummy, dummy.next
            while curr:
                l1 = curr
                l2 = self._split(l1, step)
                curr = self._split(l2, step)
                prev = self._merge(l1, l2, prev)
            step <<= 1
            
        return dummy.next

    def _split(self, head: Optional[ListNode], step: int) -> Optional[ListNode]:
        """
        Splits the linked list into two parts: the first 'step' nodes and the rest.
        Returns the head of the second part.
        """
        if not head:
            return None
        curr = head
        for _ in range(step - 1):
            if curr.next:
                curr = curr.next
            else:
                break
        
        next_part = curr.next
        curr.next = None
        return next_part
    
    def _merge(self, l1: Optional[ListNode], l2: Optional[ListNode], prev: ListNode) -> ListNode:
        """
        Merges two sorted lists and attaches the result to the 'prev' node.
        Returns the tail of the merged list.
        """
        curr = prev
        while l1 and l2:
            if l1.val <= l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        
        curr.next = l1 or l2
        while curr.next:
            curr = curr.next
        return curr
