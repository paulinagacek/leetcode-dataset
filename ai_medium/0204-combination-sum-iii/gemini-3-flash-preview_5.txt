class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res = []
        
        def backtrack(start: int, target: int, path: List[int]):
            # If the combination has the required number of elements
            if len(path) == k:
                # If the sum of the elements matches the target sum
                if target == 0:
                    res.append(list(path))
                return
            
            # Explore numbers from start to 9
            for i in range(start, 10):
                # If the current number is already greater than the remaining target sum,
                # there's no need to check further numbers in this branch.
                if i > target:
                    break
                
                # Choose the number and move forward
                path.append(i)
                # i + 1 ensures each number is used at most once
                backtrack(i + 1, target - i, path)
                # Backtrack to explore other possibilities
                path.pop()
        
        # Start the recursion with number 1 and the target sum n
        backtrack(1, n, [])
        return res
